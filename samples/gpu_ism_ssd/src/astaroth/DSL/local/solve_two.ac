#include "../prerequisites.h"

Field ERROR[mvar] // Errors

Kernel twopass_solve_intermediate(int step_num, real dt) {
  update_uu , error_uu  = rk4_intermediate(UU,     duu_dt(step_num), step_num, dt)
  update_rho, error_rho = rk4_intermediate(RHO, dlnrho_dt(step_num), step_num, dt)
  update_aa , error_aa  = rk4_intermediate(AA,     daa_dt(step_num), step_num, dt)
  update_ss , error_ss  = rk4_intermediate(SS, denergy_dt(step_num), step_num, dt)

  write( UU , update_uu )
  write( RHO, update_rho)
  write( AA , update_aa )
  write( SS , update_ss )
  if(step_num==0)
  {
    write(ERROR[UUX], error_uu.x)
    write(ERROR[UUY], error_uu.y)
    write(ERROR[UUZ], error_uu.z)
    write(ERROR[RHO], error_rho )
    write(ERROR[SS] , error_ss  )
    write(ERROR[AAX], error_aa.x)
    write(ERROR[AAY], error_aa.y)
    write(ERROR[AAZ], error_aa.z)
  }
  else
  {
    write(ERROR[UUX], ERROR[UUX] + error_uu.x)
    write(ERROR[UUY], ERROR[UUY] + error_uu.y)
    write(ERROR[UUZ], ERROR[UUZ] + error_uu.z)
    write(ERROR[RHO], ERROR[RHO] + error_rho )
    write(ERROR[SS] , ERROR[SS]  + error_ss  )
    write(ERROR[AAX], ERROR[AAX] + error_aa.x)
    write(ERROR[AAY], ERROR[AAY] + error_aa.y)
    write(ERROR[AAZ], ERROR[AAZ] + error_aa.z)
  }

}


fixed_boundary Kernel twopass_solve_final(int step_num, real dt){


  update_uu = rk4_final(UU,  step_num, dt)
  update_rho= rk4_final(RHO, step_num, dt)
  update_aa = rk4_final(AA,  step_num, dt)
  update_ss = rk4_final(SS,  step_num, dt)
  maximum_error=0.0
  if(step_num==4)
  {
    scal = max(abs(update_uu.x),AC_dt_epsi)
    maximum_error = max(abs(ERROR[UUX]/scal),maximum_error)
    scal = max(abs(update_uu.y),AC_dt_epsi)
    maximum_error = max(abs(ERROR[UUY]/scal),maximum_error)
    scal = max(abs(update_uu.z),AC_dt_epsi)
    maximum_error = max(abs(ERROR[UUZ]/scal),maximum_error)
    scal = max(abs(update_aa.x),AC_dt_epsi)
    maximum_error = max(abs(ERROR[AAX]/scal),maximum_error)
    scal = max(abs(update_aa.y),AC_dt_epsi)
    maximum_error = max(abs(ERROR[AAY]/scal),maximum_error)
    scal = max(abs(update_aa.z),AC_dt_epsi)
    maximum_error = max(abs(ERROR[AAZ]/scal),maximum_error)
    scal = max(abs(update_rho),AC_dt_epsi)
    maximum_error = max(abs(ERROR[RHO]/scal),maximum_error)
    scal = max(abs(update_ss),AC_dt_epsi)
    maximum_error = max(abs(ERROR[SS] /scal),maximum_error)

  }
  reduce_max(step_num==4, maximum_error, AC_maximum_error)

  write( UU,  update_uu  )
  write( RHO, update_rho )
  write( AA,  update_aa  )
  write( SS,  update_ss  )
}

#include "steps_two.h"
